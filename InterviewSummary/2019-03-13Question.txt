１、内存分配：
　（１） 栈：内存由编译器在需要时自动分配和释放。通常用来存储局部变量和函数参数。
  （２） 堆：内存使用new进行分配使用delete或delete[]释放。如果未能对内存进行正确的释放，会造成内存泄漏。但在程序结束时，会由操作系统自动回收。
  （３） 自由存储区：使用malloc进行分配，使用free进行回收。和堆类似。
  （４） 全局/静态存储区：全局变量和静态变量被分配到同一块内存中，C语言中区分初始化和未初始化的，C++中不再区分了。
２、重写、重载：
　（１）重写：
　　　　override是重写（覆盖）了一个方法，以实现不同的功能。一般用于子类在继承父类时，重写（覆盖）父类中的方法。函数特征相同，但是具体实现不同。重写需要注意：
　　被重写的函数不能是static的，必须是virtual的
    重写函数必须有相同的类型，名称和参数列表
    重写函数的访问修饰符可以不同。尽管virtual是private的，派生类中重写改写为public、protect也是可以的
　（２）重载：
　　　　overload是重载，一般是在一个类实现若干重载的方法，这些方法的名称相同而参数形式不同。但是不能靠返回类型来判断。
　　重载需要注意：位于同一个类中
    　　　　　　　函数的名字必须相同
    　　　　　　　形参列表不同
    若一个重载版本的函数面前有virtual修饰，则表示他是虚函数，但他也是属于重载的一个版本
    不同的构造函数(无参构造、有参构造、拷贝构造）是重载的应用
３、virtual:
    被virtual修饰的分为两类：虚函数和虚继承
  （１）虚函数：virtual void fun();
　　　　　　子类重写父类的虚函数后，可以将子类的对象赋值给父类的指针，通过指针调用虚函数实现运行时多态。
  （２）虚继承：消除多重继承的二义性
　　　　　　　　　　　　class A{};
　　　　　　　　　　　　class B1 :public virtual A{};
　　　　　　　　　　　　class B2 :public virtual A{};
　　　　　　　　　　　　class D  :public B1,public B2{};
４、const char *ptr：定义一个指向字符常量的指针，这里，ptr是一个指向 char* 类型的常量，所以不能用ptr来修改所指向的内容（即不能通过地址改变数据内容）；
　　　　char * const ptr：定义一个指向字符的指针常数，即const指针，不能修改ptr指针，但是可以修改该指针指向的内容。
　　可以通过定义const char* const ptr来实现一个常指针常量取代define宏定义。
５、c++11特性：智能指针：
　　　　shared_ptr、unique_ptr、weak_ptr
　　重点关注shared_ptr：shared_ptr使用引用计数，每一个shared_ptr的拷贝都指向相同的内存。每使用他一次，内部的引用计数加1，每析构一次，内部的引用计数减1，减为0时，自动删除所指向的堆内存。
　　　　　　　　　　　　　　　　　　　　　　　shared_ptr内部的引用计数是线程安全的，但是对象的读取需要加锁。
　　其余的不太了解，可自行查阅相关文档。
６、dbus原理:　百度得知：
　　　　D-Bus是一个消息总线系统，其功能已涵盖进程间通信的所有需求，并具备一些特殊的用途。D-Bus是三层架构的进程间通信系统，其中包括：
　　　　　接口层：接口层由函数库libdbus提供，进程可通过该库使用D-Bus的能力。
　　　　　总线层：总线层实际上是由D-Bus总线守护进程提供的。它在Linux系统启动时运行，负责进程间的消息路由和传递，其中包括Linux内核和Linux桌面环境的消息传递。
　　　　　包装层：包装层一系列基于特定应用程序框架的Wrapper库。
　　　　D-Bus具备自身的协议，协议基于二进制数据设计，与数据结构和编码方式无关。
　　　　DBUS是支持一对一和多对多的对等通讯，在一对一的直接通讯时，两个应用程序连接在一起，这是最简单的工作方式。在多对多的通讯时，这就需要一个叫DBUS后台的角色去分转，一个应用程序发消息给另外一个应用程序，先到达后台，再让
　　后台将信息发送到目的应用程序。在这里DBUS后台就充当着一个路由器的角色。