1：内存分配
	栈：内存由编译器在需要时自动分配和释放。通常用来存储局部变量和函数参数；
	堆：内存使用new进行分配使用delete或delete[]释放。如果未能对内存进行正确的释放，
	    会造成内存泄漏。但在程序结束时，会由操作系统自动回收。
	自由存储区：使用malloc进行分配，使用free进行回收。和堆类似。
	全局/静态存储区：全局变量和静态变量被分配到同一块内存中，C语言中区分初始化和未初始化的，C++中不再区分了。
2：重写、重载、重定义区别
	重载-同一类中，函数名相同、参数列表不完全相同（参数个数或者类型不同）、
		 返回值类型可以相同也可以不同；
	重定义-也称为隐藏，子类与父类中，函数名相同、参数列表与返回值可以相同
	       也可以不同；
	重写-也称为覆盖，子类中函数与父类中虚函数同名、参数列表相同、返回值可以
	     相同也可以不同（返回值不同时，返回值类型必须是父子继承关系）；
	
	重载：是为了让类能够以统一的方式处理不同类型数据，是多态性的一种表现；	
	重定义：隐藏父类中其他的同名函数（父类中可能存在多个同名函数即重载情况）；	
	重写：父类中的方法必须有virtual修饰，不能是static的；
	
3：virtual
	virtual用于修饰类函数时，函数被称为虚函数，主要作用是运行时多态。
	定义为virtual的函数是基类期待子类重新定义的，如果没有重定义则使用基类中的版本；
	虚函数分为普通虚函数与纯虚函数：
		普通虚函数一般用来在子类中重写以实现子类特殊化，函数在基类中声明为虚函数则
		一直为虚函数，子类中无法改变这一属性，另外子类中是否使用virtual是可选的；
		
		纯虚函数是作为子类中可以覆盖的接口，但基类中不会调用，含有一个或者多个纯虚函数
		的基类为抽象类，不能创建抽象类类型的对象；
	
	virtual用于类继承是，声明该基类为子类的虚基类，解决在多继承情况下的二义性问题，以及
	节省内存，避免数据不一致问题；
	

4：const char*与char* const区别
	const char*ptr是定义一个指向char类型常量的指针，即ptr指向char *类型的常量，
	所以不能用ptr来修改指向的内容，简单来说就是不能通过ptr来修改所指向的内容的数据
	
	char * const ptr是定义一个指向char类型的指针常量，即指针为const数据，所以
	不能使得指针指向另一个char类型数据

5：c++11特性
	右值引用
	可变参数模板
	auto关键字
	emplace_back替换push_back
	局部静态变量的内存初始化是线程安全的